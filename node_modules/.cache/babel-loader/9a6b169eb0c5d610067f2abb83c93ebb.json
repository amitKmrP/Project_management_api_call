{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useRef, useState } from \"react\";\nimport { clamp, distance } from \"popmotion\";\nimport move from \"array-move\"; // var { clamp, distance } = \"popmotion\";\n\nexport function usePositionReorder(initialState) {\n  _s();\n\n  const [order, setOrder] = useState(initialState);\n  const positions = useRef([]).current;\n\n  const updatePosition = (i, offset) => positions[i] = offset;\n\n  const updateOrder = (i, dragOffset) => {\n    const targetIndex = findIndex(i, dragOffset, positions);\n    if (targetIndex !== i) setOrder(move(order, i, targetIndex));\n  };\n\n  return [order, updatePosition, updateOrder];\n}\n\n_s(usePositionReorder, \"oEWEQ7/hXdl287frQtWMo0SaVvk=\");\n\nconst buffer = 30;\nexport const findIndex = (i, yOffset, positions) => {\n  let target = i;\n  const {\n    top,\n    height\n  } = positions[i];\n  const bottom = top + height; // If moving down\n\n  if (yOffset > 0) {\n    const nextItem = positions[i + 1];\n    if (nextItem === undefined) return i;\n    const swapOffset = distance(bottom, nextItem.top + nextItem.height / 2) + buffer;\n    if (yOffset > swapOffset) target = i + 1; // If moving up\n  } else if (yOffset < 0) {\n    const prevItem = positions[i - 1];\n    if (prevItem === undefined) return i;\n    const prevBottom = prevItem.top + prevItem.height;\n    const swapOffset = distance(top, prevBottom - prevItem.height / 2) + buffer;\n    if (yOffset < -swapOffset) target = i - 1;\n  }\n\n  return clamp(0, positions.length, target);\n};","map":{"version":3,"sources":["/home/amit/Desktop/Project_management_api_call/src/components/ListCards/usePositionReorder.js"],"names":["useRef","useState","clamp","distance","move","usePositionReorder","initialState","order","setOrder","positions","current","updatePosition","i","offset","updateOrder","dragOffset","targetIndex","findIndex","buffer","yOffset","target","top","height","bottom","nextItem","undefined","swapOffset","prevItem","prevBottom","length"],"mappings":";;AAAA,SAASA,MAAT,EAAiBC,QAAjB,QAAiC,OAAjC;AACA,SAASC,KAAT,EAAgBC,QAAhB,QAAgC,WAAhC;AACA,OAAOC,IAAP,MAAiB,YAAjB,C,CAEA;;AAEA,OAAO,SAASC,kBAAT,CAA4BC,YAA5B,EAA0C;AAAA;;AAC7C,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBP,QAAQ,CAACK,YAAD,CAAlC;AAEA,QAAMG,SAAS,GAAGT,MAAM,CAAC,EAAD,CAAN,CAAWU,OAA7B;;AACA,QAAMC,cAAc,GAAG,CAACC,CAAD,EAAIC,MAAJ,KAAgBJ,SAAS,CAACG,CAAD,CAAT,GAAeC,MAAtD;;AAEA,QAAMC,WAAW,GAAG,CAACF,CAAD,EAAIG,UAAJ,KAAmB;AACrC,UAAMC,WAAW,GAAGC,SAAS,CAACL,CAAD,EAAIG,UAAJ,EAAgBN,SAAhB,CAA7B;AACA,QAAIO,WAAW,KAAKJ,CAApB,EAAuBJ,QAAQ,CAACJ,IAAI,CAACG,KAAD,EAAQK,CAAR,EAAWI,WAAX,CAAL,CAAR;AACxB,GAHD;;AAKA,SAAO,CAACT,KAAD,EAAQI,cAAR,EAAwBG,WAAxB,CAAP;AACD;;GAZaT,kB;;AAcd,MAAMa,MAAM,GAAG,EAAf;AAEA,OAAO,MAAMD,SAAS,GAAG,CAACL,CAAD,EAAIO,OAAJ,EAAaV,SAAb,KAA2B;AAClD,MAAIW,MAAM,GAAGR,CAAb;AACA,QAAM;AAAES,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAkBb,SAAS,CAACG,CAAD,CAAjC;AACA,QAAMW,MAAM,GAAGF,GAAG,GAAGC,MAArB,CAHkD,CAKlD;;AACA,MAAIH,OAAO,GAAG,CAAd,EAAiB;AACf,UAAMK,QAAQ,GAAGf,SAAS,CAACG,CAAC,GAAG,CAAL,CAA1B;AACA,QAAIY,QAAQ,KAAKC,SAAjB,EAA4B,OAAOb,CAAP;AAE5B,UAAMc,UAAU,GACdvB,QAAQ,CAACoB,MAAD,EAASC,QAAQ,CAACH,GAAT,GAAeG,QAAQ,CAACF,MAAT,GAAkB,CAA1C,CAAR,GAAuDJ,MADzD;AAEA,QAAIC,OAAO,GAAGO,UAAd,EAA0BN,MAAM,GAAGR,CAAC,GAAG,CAAb,CANX,CAQf;AACD,GATD,MASO,IAAIO,OAAO,GAAG,CAAd,EAAiB;AACtB,UAAMQ,QAAQ,GAAGlB,SAAS,CAACG,CAAC,GAAG,CAAL,CAA1B;AACA,QAAIe,QAAQ,KAAKF,SAAjB,EAA4B,OAAOb,CAAP;AAE5B,UAAMgB,UAAU,GAAGD,QAAQ,CAACN,GAAT,GAAeM,QAAQ,CAACL,MAA3C;AACA,UAAMI,UAAU,GAAGvB,QAAQ,CAACkB,GAAD,EAAMO,UAAU,GAAGD,QAAQ,CAACL,MAAT,GAAkB,CAArC,CAAR,GAAkDJ,MAArE;AACA,QAAIC,OAAO,GAAG,CAACO,UAAf,EAA2BN,MAAM,GAAGR,CAAC,GAAG,CAAb;AAC5B;;AAED,SAAOV,KAAK,CAAC,CAAD,EAAIO,SAAS,CAACoB,MAAd,EAAsBT,MAAtB,CAAZ;AACD,CAzBM","sourcesContent":["import { useRef, useState } from \"react\";\r\nimport { clamp, distance } from \"popmotion\";\r\nimport move from \"array-move\";\r\n\r\n// var { clamp, distance } = \"popmotion\";\r\n\r\nexport function usePositionReorder(initialState) {\r\n    const [order, setOrder] = useState(initialState);\r\n  \r\n    const positions = useRef([]).current;\r\n    const updatePosition = (i, offset) => (positions[i] = offset);\r\n  \r\n    const updateOrder = (i, dragOffset) => {\r\n      const targetIndex = findIndex(i, dragOffset, positions);\r\n      if (targetIndex !== i) setOrder(move(order, i, targetIndex));\r\n    };\r\n  \r\n    return [order, updatePosition, updateOrder];\r\n  }\r\n  \r\n  const buffer = 30;\r\n  \r\n  export const findIndex = (i, yOffset, positions) => {\r\n    let target = i;\r\n    const { top, height } = positions[i];\r\n    const bottom = top + height;\r\n  \r\n    // If moving down\r\n    if (yOffset > 0) {\r\n      const nextItem = positions[i + 1];\r\n      if (nextItem === undefined) return i;\r\n  \r\n      const swapOffset =\r\n        distance(bottom, nextItem.top + nextItem.height / 2) + buffer;\r\n      if (yOffset > swapOffset) target = i + 1;\r\n  \r\n      // If moving up\r\n    } else if (yOffset < 0) {\r\n      const prevItem = positions[i - 1];\r\n      if (prevItem === undefined) return i;\r\n  \r\n      const prevBottom = prevItem.top + prevItem.height;\r\n      const swapOffset = distance(top, prevBottom - prevItem.height / 2) + buffer;\r\n      if (yOffset < -swapOffset) target = i - 1;\r\n    }\r\n  \r\n    return clamp(0, positions.length, target);\r\n  };"]},"metadata":{},"sourceType":"module"}